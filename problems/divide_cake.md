### 分蛋糕

原题链接

[https://pintia.cn/problem-sets/1878364856827387904/exam/problems/type/7?problemSetProblemId=1879110625968676864&amp;page=0]: 分蛋糕	"分蛋糕"

#### 题目大意：

幼儿园老师给小明过生日，给小明N个蛋糕的直径，让他给F+1个小朋友分蛋糕，每个小孩的蛋糕必须是一整块的，不能是拼起来的且面积大小一样大，问这个面积最大是多大？

##### 输入格式:

一行有一个正整数:测试用例的数量。然后对于每个测试用例:

•一行两个整数N和F, 1≤N, F≤10000:饼的数量和朋友的数量。

•一行N个整数ri， 1≤ri≤10000:饼的半径。

##### 输出格式:

对于每个测试用例，输出一行最大的容量V，这样小明和小明的朋友都可以得到大小为V的饼。答案应该作为一个浮点数给出，绝对误差不超过10^−3。

##### 输入样例:

```in
3
3 3
4 3 3
1 24
5
10 5
1 4 2 3 4 5 6 5 4 2
```

##### 输出样例:

```out
25.1327
3.1416
50.2655
```

***********

## 简单分析一下

当分给每个人的面积足够小的时候，我们一定可以完成分配任务，反之，当每个人的蛋糕的面积越大，那么我们能分给的人就越少，这时候人虽然是一定的，我们就可以利用这个面积的区间，进行二分



第一次做的时候有**第一个坑**踩到了：就是小数的二分与整数的二分不一样，不能简单的使用
$$
while(l < r)
$$
来判断二分条件

**应该使用：**
$$
while(r - l > 1e^{-6})
$$
循环条件变成了两个数的差值小于目标精度的时候才结束

***********

##### 只注意这一点肯定是不行的，这道题还有另一个坑：

要是在每次check（mid）的时候就单纯的使用：
$$
cnt += num[ i ] / mid;
$$
的话，会有一些测试点过不了，原因是，这道题我们会将几乎除了 n 和 f 的其他所有值都定义为double类型，而每一个完整的蛋糕，只能分成整数块的蛋糕，意思就是多余的边角料经过公式计算之后，会返回一个浮点数，这个浮点数的小数部分我们**不需要**且**不能**让它加到cnt里面去，因为如果多个边角料加在一起要是超过1.0了就会影响最后二分的结果，所以我们需要在check的时候进行向下取整
$$
cnt += floor(num[i] / mid);
$$

***********



## 知识拓展

`π`这个值在某些计算还是比较重要的，比如这道题，最后叫我们输出面积，我们就要记得乘上一个`π`，然而我们有时候只用3.1415926会错，其实π在`<cmath>`和`<math.h>`两个头文件有一个宏定义，在引用了这两个头文件之后我们就可以直接用`M_PI`来代替π的值了



下面给出AC代码：

```c++
#include <iostream>
#include <cmath>
using namespace std;

const int N = 1e4 + 10;
double num[N];
int n, f;

bool check(double x) // 传入的值是double类型，不要搞错了
{
    int cnt = 0;
    for(int i = 0; i < n; i ++)
    {
        cnt += floor(num[i] / x); // 向下取整
        if(cnt >= f + 1) // 提前return，防止发生溢出错误
            return 1;
    }
    return 0;
}

void solve()
{
    cin >> n >> f;
    double maxx = 0;
    for(int i = 0; i < n; i ++)
    {
        double r;
        cin >> r;
        num[i] = r * r * M_PI; // 直接将读入的半径转化为面积
        maxx = max (maxx, num[i]); // 用maxx来确定右边界
    }
    double l = 0, r = maxx;
    // 二分过程：
    while(r - l > 1e-6)
    {
        double mid = (l + r) / 2;
        if( check(mid) ) // check成功，则说明蛋糕还可能分的更小，调整左边界
            l = mid;
        else
            r = mid;
    }
    // 最后输出l或者是r都是可以的
    printf("%.4f\n", l);
} 

int main()
{
    int t;
    cin >> t;
    while(t --)
    {
        solve();
    }
    
    return 0;
}
```

完美解决